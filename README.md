### 设计模式
#### 创建型模式
##### [单例模式](./src/singleton)
##### [原型模式](./src/prototype)
原型模式主要包含以下角色
1.抽象原型类：规定了具体原型对象必须实现的接口
2.具体原型类：实现抽象原型类的clone()方法，它是可被复制的对象
3.访问类：使用具体原型类中的clone()方法来复制新的对象
应用场景
1.对象之间相同或相似，即只是个别的几个属性不同的时候。
2.创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。
3.创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。
4.系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。
在 Spring 中，原型模式应用的非常广泛，例如 scope='prototype'、JSON.parseObject() 等都是原型模式的具体应用
##### [简单工厂模式](./src/simplefactory) - 不在GOF23种设计模式之列
简单工厂模式主要包含以下角色
简单工厂：简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。
抽象产品：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。
具体产品：是简单工厂模式的创建目标
##### [工厂方法模式](./src/factorymethod)
工厂方法模式主要包含以下角色
抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。
具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。
##### [抽象工厂模式](./src/abstractfactory)
抽象工厂模式主要包含以下角色
抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。
具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。
抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如Java的AWT中的Button和Text等构件在Windows和Unix中的本地实现是不同的
##### [建造者模式](./src/builder)
建造者模式主要包含以下角色
产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。
抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。
具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。
指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。
如果创建简单对象，通常都是使用工厂模式进行创建，而如果创建复杂对象，就可以考虑使用建造者模式。
##### [结构型模式概述](./src/proxy)
代理模式的主要角色如下
抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。
根据代理的创建时期，代理模式分为静态代理和动态代理。
静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。
动态：在程序运行时，运用反射机制动态创建而成
##### 适配器模式-1.[类适配器模式](./src/classadapter) 2.[对象适配器模式](./src/objectadapter)
适配器模式的主要角色如下
目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。
适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。
适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。
适配器模式（Adapter）通常适用于以下场景。
以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。
##### 桥接模式
桥接模式的主要角色如下
抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。
扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。
具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。